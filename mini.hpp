// A very minimal .INI reader/writer (C++11)
// - rlyeh, zlib/libpng licensed

#pragma once
#include <cstring>
#include <string>
#include <map>
#include <vector>

#define MINI_VERSION "1.0.0" // (2015/09/18) Initial version

template<typename key, typename variant>
struct mINI_basic : std::map< key, variant > {

    // Public API : existing std::map<> interface plus following methods

    bool load( const std::string &text ) {
        // reset, split lines and parse
        *this = mINI_basic();
        std::vector<std::string> lines = tokenize(text, "\r\n");
        std::string symbol, tag;
        for( auto end = lines.size(), L = end - end; L < end; ++L ) {
            auto &line = lines[ L ];
            // trim blanks
            while( line.size() && ( line.back()=='\t' || line.back()==' ' ) ) line.pop_back();
            while( line.size() && ( line.front()=='\t' || line.front()==' ' ) ) line = line.substr(1);
            // split line into tokens and parse tokens
            if( line.size() >= 3 && line.front() != ';' ) {
                if( !( line.front() == '[' && line.back() == ']' )) {
                    for( auto at = line.find_first_of('='); at != std::string::npos; ) {
                        numlines[ symbol = tag + "." + line.substr( 0, at ) ] = L + 1;
                        (*this)[ symbol ] = line.substr( at + 1 ); break;
                    }
                } else tag = line.substr(1, line.size() - 2);
            }
            // std::cout << "L" << L << " " << line << std::endl; // debug
        }
        return !this->empty();
    }

    std::string save() const {
        std::string output( "; auto-generated by mINI class {\r\n" ), tag;
        for( auto &it : *this ) {
            std::vector<std::string> kv = tokenize(it.first, ".");
            if( tag != kv[0] ) {
                output += "\r\n[" + ( tag = kv[0] ) + "]\r\n";
            }
            output += kv[1] + "=" + it.second + "\r\n";
        }
        return output + "\r\n; } ---\r\n";
    }

    std::map< key, unsigned > numlines;

    unsigned line( const std::string &symbol ) const {
        auto find = numlines.find(symbol);
        return find == numlines.end() ? 0 : find->second;
    }

    private: std::vector< std::string > tokenize( const std::string &self, const std::string &chars ) const {
        std::vector< std::string > tokens(1);
        std::string map( 256, '\0' );
        for( const unsigned char &ch : chars ) map[ ch ] = '\1';
        for( const unsigned char &ch : self ) {
            /**/ if( !map.at(ch)          ) tokens.back().push_back( char(ch) );
            else if( tokens.back().size() ) tokens.push_back( std::string() );
        }
        while( tokens.size() && tokens.back().empty() ) tokens.pop_back();
        return tokens;
    };
};

using mINI = mINI_basic<std::string, std::string>;
