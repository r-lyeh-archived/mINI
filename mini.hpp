// A very minimal .INI reader/writer (C++11)
// - rlyeh, zlib/libpng licensed

#ifndef MINI_VERSION
#define MINI_VERSION "1.0.2" /* (2016/06/02) Allow relaxed spec parsing; Renamed methods (load/save to parse/dump); Optional header/footer when dumping
#define MINI_VERSION "1.0.1" // (2016/04/28) Improve symbol trimming
#define MINI_VERSION "1.0.0" // (2015/09/18) Initial version */

#include <cstring>
#include <string>
#include <map>
#include <vector>

template<typename key, typename variant>
struct mINI_basic : std::map< key, variant > {

    // Public API : existing std::map<> interface plus following methods

    bool parse( const std::string &text ) {
        // reset, split lines and parse
        *this = mINI_basic();
        std::vector<std::string> lines = tokenize(text, "\r\n");
        std::string symbol, tag;
        for( auto end = lines.size(), L = end - end; L < end; ++L ) {
            auto &line = lines[ L ];
            // trim blanks
            auto trim = []( std::string line ) {
                while( line.size() && ( line.back()=='\t' || line.back()==' ' ) ) line.pop_back();
                while( line.size() && ( line.front()=='\t' || line.front()==' ' ) ) line = line.substr(1);
                return line;
            };
            line = trim(line);
            // split line into tokens and parse tokens
            if( line.size() >= 1 && line.front() != ';' ) {
                if( line.size() >= 3 && line.front() == '[' && line.back() == ']' ) {
                    tag = trim( line.substr(1, line.size() - 2) );
                } else {
                    auto at = line.find_first_of('=');
                    numlines[ symbol = trim( tag + "." + line.substr( 0, at ) ) ] = L + 1;
                    (*this)[ symbol ] = at == std::string::npos ? std::string() : trim( line.substr( at + 1 ) );
                }
            }
            // std::cout << "L" << L << " " << line << std::endl; // debug
        }
        return !this->empty();
    }

    std::string dump( const std::string &header = "; auto-generated by mINI class {", const std::string &footer = "; } ---") const {
        std::string output( header + ( header.empty() ? "" : "\r\n" ) ), tag;
        for( auto &it : *this ) {
            std::vector<std::string> kv = tokenize(it.first, ".");
            if( tag != kv[0] ) {
                output += "\r\n[" + ( tag = kv[0] ) + "]\r\n";
            }
            output += kv[1] + "=" + it.second + "\r\n";
        }
        return output + "\r\n" + footer + ( footer.empty() ? "" : "\r\n");
    }

    std::map< key, unsigned > numlines;

    unsigned line( const std::string &symbol ) const {
        auto find = numlines.find(symbol);
        return find == numlines.end() ? 0 : find->second;
    }

    private: std::vector< std::string > tokenize( const std::string &self, const std::string &chars ) const {
        std::vector< std::string > tokens(1);
        std::string map( 256, '\0' );
        for( const unsigned char &ch : chars ) map[ ch ] = '\1';
        for( const unsigned char &ch : self ) {
            /**/ if( !map.at(ch)          ) tokens.back().push_back( char(ch) );
            else if( tokens.back().size() ) tokens.push_back( std::string() );
        }
        while( tokens.size() && tokens.back().empty() ) tokens.pop_back();
        return tokens;
    };
};

using mINI = mINI_basic<std::string, std::string>;

#endif


#ifdef MINI_BUILD_EXTENDED_DEMO
#include <iostream>
#include <cassert>
//  handy variant class as key/values
struct variant : public std::string {
    template<typename T>
    variant( const T &t ) : std::string( std::to_string(t) )
    {}
    template<size_t N>
    variant( const char (&s)[N] ) : std::string( s, N )
    {}
    variant( const char *cstr ) : std::string( cstr )
    {}
    variant( const std::string &other = std::string() ) : std::string(other)
    {}
    template<typename T>
    operator T() const {
        T t;
        std::stringstream ss;
        return ss << *this && ss >> t ? t : T();
    }
    template<typename T> bool operator ==( const T &t ) const {
        return 0 == this->compare( variant( t ) );
    }
    bool operator ==( const char *t ) const {
        return this->compare( t ) == 0;
    }
};
// use mINI with our variant class, as follows:
using mini_variant = mINI_basic<std::string, variant>;
int main() {
    // load file
    std::string content =
    "; this is a comment\n"
    "[test\t]\r\n"
    "number = 123\n"
    " \tstring=hello world\r"
    "regularkey=123\n"
    "emptykey=\n"
    "freekey\n";

    // parse content
    mini_variant ini;
    bool ok = ini.parse( content );

    // tests (notice lack of value casting due to implicit variant operators)
    assert( ini["test.number"] == 123 );           // symbol value
    assert( ini["test.string"] == "hello world" ); // symbol value

    assert( ini.line("test.number") == 3 );        // line number
    assert( ini.line("test.string") == 4 );        // line number

    // append new symbols
    ini["added.number"] = 456;
    ini["added.string"] = "new string";

    // dump and print
    std::cout << ini.dump() << std::endl;
}
#endif

#ifdef MINI_BUILD_BASIC_DEMO
#include <iostream>
#include <cassert>
int main() {
    // load file
    std::string content =
    "; this is a comment\n"
    "[test\t]\r\n"
    "number = 123\n"
    " \tstring=hello world\r"
    "regularkey=123\n"
    "emptykey=\n"
    "freekey\n";

    // parse content
    mINI ini;
    bool ok = ini.parse( content );

    std::cout << ini.dump() << std::endl;

    // tests
    assert( ini["test.number"] == "123" );         // symbol value
    assert( ini["test.string"] == "hello world" ); // symbol value

    assert( ini.line("test.number") == 3 );        // line number
    assert( ini.line("test.string") == 4 );        // line number

    // append new symbols
    ini["added.number"] = "456";
    ini["added.string"] = "new string";

    // dump and print
    std::cout << ini.dump() << std::endl;
}
#endif

